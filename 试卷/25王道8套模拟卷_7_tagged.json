[
    {
        "exerciseType": "单选题",
        "stem": "<p>一个带头结点的单链表，头指针为 L，尾指针 r 指向最后一个结点，要保证插入的先后顺序与对应结点在链中的顺序相反，则插入 p 结点的操作为（）。</p>",
        "options": {
            "A": "<p>L->next=p; p->next=L->next;</p>",
            "B": "<p>$p->next = L->next$ ; $L->next = p$ ;</p>",
            "C": "<p>$r->\\text{next} = p; r = p;$</p>",
            "D": "<p>$p->\\text{next} = r$ ;</p>"
        },
        "answer": "B",
        "analysis": "<p>本题考查链表的操作。</p><p>要保证插入的先后顺序与对应结点在链中的顺序相反，必须使用头插法（尾插法插入的先后顺序与链中的顺序相同），所以排除选项 C、D。在选项 A 中，执行 L->next=p 后会导致断链。</p>",
        "fromSchool": "25王道8套",
        "examTime": "2024年",
        "examCode": "408",
        "examFullName": "计算机学科基础综合（七）",
        "exerciseNumber": 1,
        "totalScore": 2,
        "knowledgeTags": [
            "1217886412335226880"
        ]
    },
    {
        "exerciseType": "单选题",
        "stem": "<p>假设用不带头结点的单链表 A 作为链式栈，其结点结构为|data|link|，top 是指向栈顶的指针。若要删除链式栈的栈顶结点，并将被删除结点的值保存到 x 中，则应执行的操作是（）。</p>",
        "options": {
            "A": "<p>$x = \\text{top} - > \\text{data}$ ;</p><p>top=top->link;</p>",
            "B": "<p>top=top->link;</p><p>x=top->data;</p>",
            "C": "<p>$x = \\text{top}$ ;</p><p>top $\\equiv$ top->link;</p>",
            "D": "<p>$x = \\text{top} - > \\text{data}$ ;</p>"
        },
        "answer": "A",
        "analysis": "<p>本题考查单链表的操作。</p><p>不带头结点的单链表A作为链式栈的结构如下图所示。</p><p>![image](https://s3.hi168.com/hi168-26998-7111ilq6/exercises/2cca7f3426114899488932f15d6a2d8f33ab772b96d4043b2ccb7c402154ce7a-1771687969924.jpg)</p><p>当栈顶结点出栈时，先用 $x$ 保存栈顶元素的值，然后移动栈顶指针。因此，正确的操作应该是 $x = \\text{top->data}$ ; $\\text{top} = \\text{top->link}$ 。</p>",
        "fromSchool": "25王道8套",
        "examTime": "2024年",
        "examCode": "408",
        "examFullName": "计算机学科基础综合（七）",
        "exerciseNumber": 2,
        "totalScore": 2,
        "knowledgeTags": [
            "1217886412335226880"
        ]
    },
    {
        "exerciseType": "单选题",
        "stem": "<p>6个元素以6,5,4,3,2,1的顺序进栈，下列不合法的出栈序列是（）。</p>",
        "options": {
            "A": "<p>5, 4, 3, 6, 1, 2</p>",
            "B": "<p>4, 5, 3, 1, 2, 6</p>",
            "C": "<p>$3, 4, 6, 5, 2, 1$</p>",
            "D": "<p>2,3,4,1,5,6</p>"
        },
        "answer": "C",
        "analysis": "<p>本题考查出栈序列的合法性。</p><p>这类题通常采用手动模拟法。A项：6入，5入，5出，4入，4出，3入，3出，6出，2入，1入，1出，2出；B项：6入，5入，4入，4出，5出，3入，3出，2入，1入，1出，2出，6出；D项：6入，5入，4入，3入，2入，2出，3出，4出，1入，1出，5出，6出；C项：无对应的合法出栈顺序。</p><p>技巧：对于已入栈且尚未出栈的序列，要保证先入栈的一定不能在后入栈的前面出栈。选项 C 的 6 在 5 前入栈，5 没有出栈，6 却出栈了，不合法。其他选项都符合规律。</p>",
        "fromSchool": "25王道8套",
        "examTime": "2024年",
        "examCode": "408",
        "examFullName": "计算机学科基础综合（七）",
        "exerciseNumber": 3,
        "totalScore": 2,
        "knowledgeTags": [
            "1217888821103042560"
        ]
    },
    {
        "exerciseType": "单选题",
        "stem": "<p>串'acaba'的 next 数组值为（）。</p>",
        "options": {
            "A": "<p>01234</p>",
            "B": "<p>01212</p>",
            "C": "<p>01121</p>",
            "D": "<p>01230</p>"
        },
        "answer": "C",
        "analysis": "<p>本题考查串的 next 数组。</p><p>1）设 next[1] = 0，next[2] = 1。</p><table><tr><td>编号</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td></tr><tr><td>S</td><td>a</td><td>c</td><td>a</td><td>b</td><td>a</td></tr><tr><td>next</td><td>0</td><td>1</td><td></td><td></td><td></td></tr></table><p>2）当 $j = 3$ 时， $k = \\text{next}[j - 1] = \\text{next}[2] = 1$ ，观察 S[2]与S[k]（S[1]）是否相等， $S[2] = c$ ， $S[1] = a$ ， $S[2] != S[1]$ ，此时 $k = \\text{next}[k] = 0$ ，所以 next[j] = 1。</p><p>![image](https://s3.hi168.com/hi168-26998-7111ilq6/exercises/91a95ae6887af2f487c6ed110c4283b8bc3bc9206af43914ed59a2672b02ef2e-1771687973672.jpg)</p><p>3）当 $j = 4$ 时， $k = \\text{next}[j - 1] = \\text{next}[3] = 1$ ，观察S[3]与S[k]（S[1]）是否相等， $S[3] = a$ ， $S[1] = a$ ， $S[2] = S[1]$ ，所以 next[j] = k + 1 = 2。</p><p>![image](https://s3.hi168.com/hi168-26998-7111ilq6/exercises/22bd79bf578f0926378749358ab09dd1aaedd6fb517d432cb68ffc8159482f21-1771687979545.jpg)</p><p>4）当 $j = 5$ 时， $k = \\text{next}[j - 1] = \\text{next}[4] = 2$ ，观察 S[4]与S[k]（S[2]）是否相等， $S[4] = b$ ， $S[2] = c$ ， $S[4] != S[2]$ ，所以 $k = \\text{next}[k] = 1$ 。</p><p>![image](https://s3.hi168.com/hi168-26998-7111ilq6/exercises/d3437a0d94d97e8652476256ab7a08ccd777cef285a7c5d097add9d5037e0430-1771687953116.jpg)</p><p>5）此时 $S[k] = S[1] = a$ ， $S[4]! = S[1]$ ，所以 $k = \\text{next}[k] = \\text{next}[1] = 0$ ，所以 $\\text{next}[j] = 1$ 。</p><p>![image](https://s3.hi168.com/hi168-26998-7111ilq6/exercises/3190adcd3441d2a4156edc2fcbf0ad5f2fff9abe0f450b4c6b5ba5d006adb5e4-1771687963401.jpg)</p><p>可知 next 数组为 01121。</p>",
        "fromSchool": "25王道8套",
        "examTime": "2024年",
        "examCode": "408",
        "examFullName": "计算机学科基础综合（七）",
        "exerciseNumber": 4,
        "totalScore": 2,
        "knowledgeTags": [
            "1217909120171253760"
        ]
    },
    {
        "exerciseType": "单选题",
        "stem": "<p>前序遍历和中序遍历结果相同的二叉树为（）。</p><p>I. 只有根结点的二叉树</p><p>II. 根结点无右孩子的二叉树</p><p>III．所有结点只有左子树的二叉树</p><p>IV. 所有结点只有右子树的二叉树</p>",
        "options": {
            "A": "<p>仅有 I</p>",
            "B": "<p>I、II 和 IV</p>",
            "C": "<p>I 和 III</p>",
            "D": "<p>I 和 IV</p>"
        },
        "answer": "D",
        "analysis": "<p>本题考查二叉树的遍历。</p><p>解法1：对于选项I，显然任何遍历都相同。对于选项II，根结点无右孩子，此时前序遍历首先遍历根结点，中序遍历最后遍历根结点，所以不相同。对于选项III，是一棵左单支树，前序遍历和后序遍历的序列相反。对于选项IV，所有结点只有右子树的右单支树，前序遍历和中序遍历的序列相同。因此，选择选项D。</p><p>解法2：若树中某棵子树存在左子树，则中序遍历一定先遍历左子树后才遍历这颗子树本身，而先序遍历则先遍历这棵子树本身，所以只要树中某个结点存在左子树，便是不符合要求的，因此任何一颗子树都没有左子树的树符合要求，选项I和选项IV符合要求。</p>",
        "fromSchool": "25王道8套",
        "examTime": "2024年",
        "examCode": "408",
        "examFullName": "计算机学科基础综合（七）",
        "exerciseNumber": 5,
        "totalScore": 2,
        "knowledgeTags": [
            "1217892396050948096"
        ]
    },
    {
        "exerciseType": "单选题",
        "stem": "<p>在以下算法中，需要用到并查集的是（）。</p>",
        "options": {
            "A": "<p>Floyd 算法</p>",
            "B": "<p>Kruskal 算法</p>",
            "C": "<p>Prim 算法</p>",
            "D": "<p>Dijkstra 算法</p>"
        },
        "answer": "B",
        "analysis": "<p>本题考查并查集和图的算法。</p><p>Kruskal 算法流程首先将所有的边从小到大排序, 然后使用并查集, 每次选最小的边, 并且该边要保证其两端的两个顶点属于不同的集合, 选择边后, 进行一次并操作, 重复选择边及并操作 $n - 1$ 次, 得到最小生成树。</p>",
        "fromSchool": "25王道8套",
        "examTime": "2024年",
        "examCode": "408",
        "examFullName": "计算机学科基础综合（七）",
        "exerciseNumber": 6,
        "totalScore": 2,
        "knowledgeTags": [
            "1217895065050161152"
        ]
    },
    {
        "exerciseType": "单选题",
        "stem": "<p>右图所示为一棵平衡二叉树（字母不是关键字），在结点 $D$ 的右子树上插入结点 $F$ 后，会导致该平衡二叉树失去平衡，则调整后的平衡二叉树中平衡因子的绝对值为 1 的分支结点数为（）。</p><p>![image](https://s3.hi168.com/hi168-26998-7111ilq6/exercises/61311aae2d22d547481fc5e6ceb9b627c72bdc50055cdf9b857347604c597649-1771687958434.jpg)</p>",
        "options": {
            "A": "<p>0</p>",
            "B": "<p>1</p>",
            "C": "<p>2</p>",
            "D": "<p>3</p>"
        },
        "answer": "B",
        "analysis": "<p>本题考查平衡二叉树的旋转。</p><p>由于在结点 $A$ 的右孩子（R）的右子树（R）上插入新结点 $F$ ， $A$ 的平衡因子由-1减至-2，因此以 $A$ 为根的子树失去平衡，需要进行RR旋转（左单旋）。</p><p>RR 旋转的过程如下图所示, 将 $A$ 的右孩子 $C$ 向左上旋转代替 $A$ 成为根结点, 将 $A$ 结点向左下旋转成为 $C$ 的左子树的根结点, 而 $C$ 原来的左子树 $E$ 则作为 $A$ 的右子树。因此, 调整后的平衡二叉树中平衡因子的绝对值为 1 的分支结点数为 1 。</p><p>![image](https://s3.hi168.com/hi168-26998-7111ilq6/exercises/b6d7ec16bf4a35b8257cda74074c1b32fbe214636b6ad3cf44c423b60109fbf3-1771687975392.jpg)</p><p>![image](https://s3.hi168.com/hi168-26998-7111ilq6/exercises/ae15b78c7955b5ce5ea4bdfcda11a9d22dd78a135b6cb0349cd13dcb1f633cdb-1771687988423.jpg)</p><p>![image](https://s3.hi168.com/hi168-26998-7111ilq6/exercises/65edad6f02a96dc6fb922c63edf53bb0b20d745f23620f9cebc6176a66f9a16a-1771687981261.jpg)</p><p>▲注意：平衡旋转的操作都是插入操作后，在引起不平衡的最小不平衡子树上进行的，只要将这个最小不平衡子树调整平衡，其上级结点将恢复平衡。</p>",
        "fromSchool": "25王道8套",
        "examTime": "2024年",
        "examCode": "408",
        "examFullName": "计算机学科基础综合（七）",
        "exerciseNumber": 7,
        "totalScore": 2,
        "knowledgeTags": [
            "1217907592857395200"
        ]
    },
    {
        "exerciseType": "单选题",
        "stem": "<p>在 AVL 树中插入一个结点后造成了不平衡，设最低的不平衡结点为 $a$ ，并已知插入前 $a$ 的左孩子的平衡因子为-1，右孩子的平衡因子为 0，则应作（）调整以使其平衡。</p>",
        "options": {
            "A": "<p>左旋</p>",
            "B": "<p>先左旋后右旋</p>",
            "C": "<p>先右旋后左旋</p>",
            "D": "<p>右旋</p>"
        },
        "answer": "B",
        "analysis": "<p>本题考查二叉平衡树的调整操作。</p><p>平衡因子指的是左、右子树的高度之差，可画出题意对应的树形如下图所示。插入结点后，如果导致以结点 $a$ 为根的子树失衡，那么插入的结点必然是结点 $b$ 的左孩子或右孩子。因为是在结点 $a$ 的左孩子的右子树上插入结点而导致失衡的，所以需要做先左旋后右旋来调整。</p><p>![image](https://s3.hi168.com/hi168-26998-7111ilq6/exercises/db8826f36148fdd156c8a2493d216fc7db58e988ee3e3299cb3f390874f5d380-1771688000829.jpg)</p>",
        "fromSchool": "25王道8套",
        "examTime": "2024年",
        "examCode": "408",
        "examFullName": "计算机学科基础综合（七）",
        "exerciseNumber": 8,
        "totalScore": 2,
        "knowledgeTags": [
            "1217907592857395200"
        ]
    },
    {
        "exerciseType": "单选题",
        "stem": "<p>在一棵含有 $n$ 个关键字的 $m$ 阶B树中进行查找，至多需要读磁盘（）次。</p>",
        "options": {
            "A": "<p>$\\log_2 n$</p>",
            "B": "<p>$1 + \\log_2 n$</p>",
            "C": "<p>$\\log_{\\lceil m / 2 \\rceil}((n + 1) / 2) + 1$</p>",
            "D": "<p>$\\log_{\\lceil n / 2\\rceil}((m + 1) / 2) + 1$</p>"
        },
        "answer": "C",
        "analysis": "<p>本题考查B树的高度。</p><p>磁盘存取次数取决于B树的高度，对有 $n$ 个关键字的 $m$ 阶B树，若让每个结点中的关键字个数最少，则容纳同样数量关键字的B树的高度达到最大。也就是说，第1层至少有1个结点；第2层至少有2个结点；除根结点外的每个非终端结点至少有 $\\lceil m / 2\\rceil$ 棵子树，则第3层至少有 $2\\lceil m / 2\\rceil$ 个结点……第 $h + 1$ 层至少有 $2(\\lceil m / 2\\rceil)^{h - 1}$ 个结点，第 $h + 1$ 层是不包含任何信息的叶结点。对关键字个数为 $n$ 的B树，叶结点数即查找不成功的结点数为 $n + 1$ ，因此有 $n + 1\\geqslant 2(\\lceil m / 2\\rceil)^{h - 1}$ ，即 $h\\leqslant \\log_{\\lceil m / 2\\rceil}((n + 1) / 2) + 1$ 。</p>",
        "fromSchool": "25王道8套",
        "examTime": "2024年",
        "examCode": "408",
        "examFullName": "计算机学科基础综合（七）",
        "exerciseNumber": 9,
        "totalScore": 2,
        "knowledgeTags": [
            "1217905254696493056"
        ]
    },
    {
        "exerciseType": "单选题",
        "stem": "<p>在下列排序方法中，时间性能与待排序记录的初始状态无关的是（）。</p>",
        "options": {
            "A": "<p>插入排序和快速排序</p>",
            "B": "<p>归并排序和快速排序</p>",
            "C": "<p>选择排序和归并排序</p>",
            "D": "<p>插入排序和归并排序</p>"
        },
        "answer": "C",
        "analysis": "<p>本题考查各种内部排序算法的性能。</p><p>选择排序在最好、最坏、平均情况下的时间性能均为 $O(n^{2})$ ，归并排序在最好、最坏、平均情况下的时间性能均为 $O(n\\log_2n)$ 。各种排序方法对应的时间复杂度如下表所示。快速排序在原序列本身有序时达到最坏的时间复杂度，直接插入排序在原序列本身有序时达到最好的时间复杂度。</p><table><tr><td>时间复杂度</td><td>直接插入</td><td>冒泡排序</td><td>简单选择</td><td>希尔排序</td><td>快速排序</td><td>堆排序</td><td>二路归并</td></tr><tr><td>平均情况</td><td>O(n2)</td><td>O(n2)</td><td>O(n2)</td><td>-</td><td>O(nlog2n)</td><td>O(nlog2n)</td><td>O(nlog2n)</td></tr><tr><td>最好情况</td><td>O(n)</td><td>O(n)</td><td>O(n2)</td><td>-</td><td>O(nlog2n)</td><td>O(nlog2n)</td><td>O(nlog2n)</td></tr><tr><td>最坏情况</td><td>O(n2)</td><td>O(n2)</td><td>O(n2)</td><td>-</td><td>O(n2)</td><td>O(nlog2n)</td><td>O(nlog2n)</td></tr></table>",
        "fromSchool": "25王道8套",
        "examTime": "2024年",
        "examCode": "408",
        "examFullName": "计算机学科基础综合（七）",
        "exerciseNumber": 10,
        "totalScore": 2,
        "knowledgeTags": [
            "1218134865606877184"
        ]
    },
    {
        "exerciseType": "单选题",
        "stem": "<p>若对29条记录只进行三趟多路平衡归并，则选取的归并路数至少是（）。</p>",
        "options": {
            "A": "<p>2</p>",
            "B": "<p>3</p>",
            "C": "<p>4</p>",
            "D": "<p>5</p>"
        },
        "answer": "C",
        "analysis": "<p>本题考查多路平衡归并。</p><p>$m$ 路平衡归并是指将 $m$ 个有序表组合为一个新有序表。每经过一趟归并, 剩下的记录数是原来的 $1 / m$ , 经过 3 趟归并后有 $\\lceil 29 / m^{3} \\rceil = 1$ , 4 为最小满足条件的数。</p><p>▲注意：本题中4和5均能满足要求，但6不满足要求。若 $m = 6$ ，则只需2趟归并便可排好顺序。因此，还需要满足 $m^2 < 29$ ，即只有4和5才满足要求。</p><p>【另解】画出选项 A、B、C 对应的满树的草图, 然后计算结点数是否能达到或超过 29 个, 若选项 C 能到达, 则选项 D 就不必画草图了, 否则必然选择选项 D。</p>",
        "fromSchool": "25王道8套",
        "examTime": "2024年",
        "examCode": "408",
        "examFullName": "计算机学科基础综合（七）",
        "exerciseNumber": 11,
        "totalScore": 2,
        "knowledgeTags": [
            "1218133558540115968"
        ]
    },
    {
        "exerciseType": "单选题",
        "stem": "<p>在某 32 位计算机中，全局变量 buf 的声明为 “int buf[4] = \\{-2, 103, -10, -20\\}；”，假定 buf 的地址为 0x8049320，则地址 0x804932a 中的内容为（）。</p>",
        "options": {
            "A": "<p>00000000</p>",
            "B": "<p>1111 1010</p>",
            "C": "<p>11110101</p>",
            "D": "<p>1111 1111</p>"
        },
        "answer": "D",
        "analysis": "<p>本题考查数据的存储和排列。</p><p>int 型变量的长度为 32 位, 即 4B, 所以 $0 \\times 804932a$ 中存放 -10 中的高位或低位的第 2 个字节, -10 的十六进制数为 FFFF FFF6H, 存放内容为 FF, 即 D。</p><p>▲注意：本题没有说明采用哪种对齐方式，不论是大端方式还是小端方式，答案均为FF。</p>",
        "fromSchool": "25王道8套",
        "examTime": "2024年",
        "examCode": "408",
        "examFullName": "计算机学科基础综合（七）",
        "exerciseNumber": 12,
        "totalScore": 2,
        "knowledgeTags": [
            "1215241761115611136"
        ]
    },
    {
        "exerciseType": "单选题",
        "stem": "<p>在 IEEE 754 标准的单精度浮点数中，最大规格化负数的机器数为（）。</p>",
        "options": {
            "A": "<p>$80 \\mathrm{C} 0 0 0 0 \\mathrm{H}$</p>",
            "B": "<p>80800000H</p>",
            "C": "<p>8000000H</p>",
            "D": "<p>80000001H</p>"
        },
        "answer": "B",
        "analysis": "<p>本题考查 IEEE 754 单精度浮点数的表示范围。</p><p>最大负数要使得符号位为 1 且绝对值最小。阶码全 1 和全 0 用作特殊用途, 因此能取得的最小阶码 (移码) 的机器数为 00000001B; 尾数位为全 0 , 因此最大规格化负数为 1000000010000000000000000000000B, 其十六进制形式为 $80800000\\mathrm{H}$ 。</p>",
        "fromSchool": "25王道8套",
        "examTime": "2024年",
        "examCode": "408",
        "examFullName": "计算机学科基础综合（七）",
        "exerciseNumber": 13,
        "totalScore": 2,
        "knowledgeTags": [
            "1215243294423130112"
        ]
    },
    {
        "exerciseType": "单选题",
        "stem": "<p>某计算机的存储系统由 Cache-主存系统构成，Cache 的存取周期为 10ns，主存的存取周期为 50ns。当 CPU 执行一段程序时，Cache 完成存取的次数为 4800 次，主存完成的存取次数为 200 次，则该 Cache-主存系统的效率是（）。（设 Cache 和主存不能同时访问。）</p>",
        "options": {
            "A": "<p>0.833</p>",
            "B": "<p>0.856</p>",
            "C": "<p>0.958</p>",
            "D": "<p>0.862</p>"
        },
        "answer": "A",
        "analysis": "<p>本题考查 Cache 命中率的相关计算。</p><p>命中率 $= 4800 / (4800 + 200) = 0.96$ ，因为Cache和主存不能同时访问，所以当Cache中没有当前块时，消耗的时间为 $10\\mathrm{ns} + 50\\mathrm{ns}$ ，平均访问时间 $= 0.96 \\times 10\\mathrm{ns} + (1 - 0.96) \\times (10\\mathrm{ns} + 50\\mathrm{ns}) = 12\\mathrm{ns}$ 。因此，效率 $= 10\\mathrm{ns} / 12\\mathrm{ns} = 0.833$ 。</p>",
        "fromSchool": "25王道8套",
        "examTime": "2024年",
        "examCode": "408",
        "examFullName": "计算机学科基础综合（七）",
        "exerciseNumber": 14,
        "totalScore": 2,
        "knowledgeTags": [
            "1215246689913544704"
        ]
    },
    {
        "exerciseType": "单选题",
        "stem": "<p>在页面尺寸为 4KB 的页式存储管理中，按字节编址，页表中的内容如下图所示，则物理地址 32773 对应的逻辑地址为（）。（本题中的所有数字均为十进制数。）</p><table><tr><td>虚页号</td><td>页框号</td><td>有效位</td><td>虚页号</td><td>页框号</td><td>有效位</td></tr><tr><td>0</td><td>2</td><td>1</td><td>3</td><td>8</td><td>1</td></tr><tr><td>1</td><td>5</td><td>1</td><td>4</td><td>7</td><td>1</td></tr><tr><td>2</td><td>7</td><td>0</td><td>5</td><td>11</td><td>1</td></tr></table>",
        "options": {
            "A": "<p>32773</p>",
            "B": "<p>42773</p>",
            "C": "<p>12293</p>",
            "D": "<p>62773</p>"
        },
        "answer": "C",
        "analysis": "<p>本题考查页式存储器中地址映射的计算。</p><p>对于本类题，要首先将物理地址转换为“物理页号+页内地址”的形式，然后查找页表，找出物理页号对应的逻辑页号，接着将“逻辑页号+页内地址”转换为对应的十进制数。页面大小为4KB，即页内地址为 $\\log_2 4\\mathrm{K} = 12$ 位， $32773 = 32768 + 5 = 1000000000000000B + 101\\mathrm{B} = 1000000000000101\\mathrm{B}$ ，后12位为页内地址，前4位为页号。物理页号为8，对应逻辑页号为 $3 = 11\\mathrm{B}$ 。因此，逻辑地址 $= 110000000000101\\mathrm{B} = 3 \\times 4\\mathrm{K} + 5 = 10240 + 2048 + 5 = 12288 + 5 = 12293$ 。</p>",
        "fromSchool": "25王道8套",
        "examTime": "2024年",
        "examCode": "408",
        "examFullName": "计算机学科基础综合（七）",
        "exerciseNumber": 15,
        "totalScore": 2,
        "knowledgeTags": [
            "1219660227406995456"
        ]
    },
    {
        "exerciseType": "单选题",
        "stem": "<p>在下列关于 Cache 和虚拟存储器的说法中，错误的有（）。</p><p>I. 当 Cache 失效（不命中）时，处理器将切换进程，以更新 Cache 中的内容</p><p>II. 当虚拟存储器失效（如缺页）时，处理器将切换进程，以更新主存中的内容</p><p>III．Cache和虚拟存储器由硬件和OS共同实现，对应用程序员均是透明的</p><p>IV. 虚拟存储器的容量等于主存和辅存的容量之和</p>",
        "options": {
            "A": "<p>I 和 IV</p>",
            "B": "<p>III 和 IV</p>",
            "C": "<p>I、II 和 III</p>",
            "D": "<p>I、III 和 IV</p>"
        },
        "answer": "D",
        "analysis": "<p>本题考查 Cache 和虚拟存储器的特性。</p><p>- Cache 失效与虚拟存储器失效的处理方法不同，Cache 完全由硬件实现，不涉及软件端；虚拟存储器由硬件和 OS 共同完成，缺页时才发出缺页中断，故选项 I 错误、选项 II 正确、选项 III 错误。虚拟存储器的大小就是虚拟地址（也称逻辑地址）空间的大小，它由虚拟（逻辑）地址的位数决定，与系统中的磁盘容量和内存容量没有直接关系，故选项 IV 错误。</p><p>▲注意：Cache 和虚拟存储器都基于程序访问的局部性原理，但它们的实现方法和作用均不太相同。Cache 是为了解决 CPU-主存的速度矛盾，而虚存是为了解决主存容量的不足。</p>",
        "fromSchool": "25王道8套",
        "examTime": "2024年",
        "examCode": "408",
        "examFullName": "计算机学科基础综合（七）",
        "exerciseNumber": 16,
        "totalScore": 2,
        "knowledgeTags": [
            "1215255177104465920"
        ]
    },
    {
        "exerciseType": "单选题",
        "stem": "<p>设寄存器 R 中的数值为 600，地址为 600 和 700 的主存单元中存放的内容分别是 700 和 800，则（）得到的操作数为 600。</p><p>I．直接寻址600</p><p>II. 寄存器间接寻址 R</p><p>III．立即寻址600</p><p>IV. 寄存器寻址 R</p>",
        "options": {
            "A": "<p>I</p>",
            "B": "<p>II、III</p>",
            "C": "<p>III、IV</p>",
            "D": "<p>IV</p>"
        },
        "answer": "C",
        "analysis": "<p>本题考查各种寻址方式。</p><p>当采用直接寻址时，操作数 $= (600) = 700$ ，选项I错误；当采用寄存器间接寻址时，操作数 $= (\\mathrm{R}) = 700$ ，选项II错误；当采用立即寻址时，操作数 $= 600$ ，选项III正确；当采用寄存器寻址时，</p><p>操作数 $= (\\mathrm{R}) = 600$ ，选项IV正确。</p>",
        "fromSchool": "25王道8套",
        "examTime": "2024年",
        "examCode": "408",
        "examFullName": "计算机学科基础综合（七）",
        "exerciseNumber": 17,
        "totalScore": 2,
        "knowledgeTags": [
            "1215259423933734912"
        ]
    },
    {
        "exerciseType": "单选题",
        "stem": "<p>假设相对寻址的转移指令占 2B，第一个字节是操作码，第二个字节是相对位移量，用补码表示。每当 CPU 从存储器中取出 1B 时，即自动完成 $(\\mathrm{PC}) + 1 \\rightarrow \\mathrm{PC}$ 。若当前 PC 值为 $2000\\mathrm{H}, 2000\\mathrm{H}$ 处的指令为 JMP * -9 (*为相对寻址特征)，则执行这条指令后，PC 值为（）。</p>",
        "options": {
            "A": "<p>1FF7H</p>",
            "B": "<p>1FF8H</p>",
            "C": "<p>1FF9H</p>",
            "D": "<p>1FFAH</p>"
        },
        "answer": "C",
        "analysis": "<p>本题考查转移指令的执行。</p><p>根据汇编语言指令JMP $* - 9$ ，即要求转移后的目标地址为PC值-09H，而相对寻址的转移指令占2B，取完指令后 $\\mathrm{PC} = (\\mathrm{PC}) + 2 = 2002\\mathrm{H}$ ， $-9 = 11110111 = \\mathrm{F7H}$ ，则跳转完成后 $\\mathrm{PC} = 2002\\mathrm{H} - 9\\mathrm{H} = 2002\\mathrm{H} + \\mathrm{FFF7H} = 1\\mathrm{FF9H}$ 。</p>",
        "fromSchool": "25王道8套",
        "examTime": "2024年",
        "examCode": "408",
        "examFullName": "计算机学科基础综合（七）",
        "exerciseNumber": 18,
        "totalScore": 2,
        "knowledgeTags": [
            "1215259378148712448"
        ]
    },
    {
        "exerciseType": "单选题",
        "stem": "<p>在下列几项中，不符合RISC指令系统特征的是（）。</p>",
        "options": {
            "A": "<p>控制器多采用微程序控制方式，以期更快的设计速度</p>",
            "B": "<p>指令格式简单, 不同指令数量少</p>",
            "C": "<p>寻址方式少且简单</p>",
            "D": "<p>所有指令的平均执行时间约为 1 个时钟周期</p>"
        },
        "answer": "A",
        "analysis": "<p>本题考查 RISC 和 CISC 的特征。</p><p>RISC 的单个指令格式简单, 完成的功能少, 指令的数量也少于 CISC (例如, 就寻址而言, CISC 有多种寻址方式, 因此指令的数量多于 RISC)。CISC 中不同的指令所花的时间不同, 如 load 指令可能需要访存, 所花的时间当然远大于一个时钟周期, 而在 RISC 中, 一个时钟周期通常执行一条微指令。CISC 采用微程序方式, RISC 采用硬布线方式。</p>",
        "fromSchool": "25王道8套",
        "examTime": "2024年",
        "examCode": "408",
        "examFullName": "计算机学科基础综合（七）",
        "exerciseNumber": 19,
        "totalScore": 2,
        "knowledgeTags": [
            "1215262623290105856"
        ]
    },
    {
        "exerciseType": "单选题",
        "stem": "<p>在微程序控制器中，微程序的入口地址是由（）形成的。</p>",
        "options": {
            "A": "<p>机器指令的地址码字段</p>",
            "B": "<p>微指令的微地址字段</p>",
            "C": "<p>机器指令的操作码字段</p>",
            "D": "<p>微指令的操作码字段</p>"
        },
        "answer": "C",
        "analysis": "<p>本题考查微程序方式的工作原理。</p><p>执行公共取指令微操作（送至指令寄存器 IR）后，由机器指令的操作码字段形成对应微程序的入口地址。在选项 A 中，机器指令的地址码字段一般不是操作数就是操作数的地址，不可能作为微程序的入口地址；另外，微指令中并不存在操作码和地址码字段，只存在控制字段、判别测试字段和下地址字段，选项 B 和 D 显然错误。</p>",
        "fromSchool": "25王道8套",
        "examTime": "2024年",
        "examCode": "408",
        "examFullName": "计算机学科基础综合（七）",
        "exerciseNumber": 20,
        "totalScore": 2,
        "knowledgeTags": [
            "1215305027082788864"
        ]
    },
    {
        "exerciseType": "单选题",
        "stem": "<p>在下列关于微指令格式的描述中，错误的是（）。</p>",
        "options": {
            "A": "<p>相对于直接控制法（不译法），字段直接编码法对控制存储器的利用率更高</p>",
            "B": "<p>相对于字段直接编码法, 直接控制法 (不译法) 的执行速度更快</p>",
            "C": "<p>相对于断定法（下址字段法），采用增量计数器法的微指令格式更短</p>",
            "D": "<p>相对于水平型微指令, 垂直型微指令包含的微命令更多</p>"
        },
        "answer": "D",
        "analysis": "<p>本题考查微指令格式的特性。</p><p>采用字段直接编码法的微指令长度更短，因此控制存储器的利用率更高，但直接控制法（不译法）的执行速度更快。采用计数器法的微指令格式时，没有下地址字段，因此指令长度更短，选项A、B、C正确。垂直型微指令相对于水平型微指令包含的微命令更少，指令更短，更规整，微程序更长，因此选项D错误。</p>",
        "fromSchool": "25王道8套",
        "examTime": "2024年",
        "examCode": "408",
        "examFullName": "计算机学科基础综合（七）",
        "exerciseNumber": 21,
        "totalScore": 2,
        "knowledgeTags": [
            "1215305027082788864"
        ]
    },
    {
        "exerciseType": "单选题",
        "stem": "<p>在下列关于各种 I/O 控制方式的说法中，错误的是（）。</p><p>I. 在中断响应周期，置“0”允许中断触发器是由关中断指令完成的</p><p>II. 中断服务程序的最后一条指令是无条件转移指令</p><p>III. CPU 通过中断来控制 DMA 接口的传输工作</p><p>IV. 程序中断和 DMA 方式都由硬件和软件结合来实现数据的传输</p>",
        "options": {
            "A": "<p>I、III、IV</p>",
            "B": "<p>III、IV</p>",
            "C": "<p>I、II、III</p>",
            "D": "<p>I、II、III、IV</p>"
        },
        "answer": "D",
        "analysis": "<p>本题考查中断方式的原理。</p><p>在中断周期中，关中断由隐指令完成，而不由关中断指令完成，选项I错误。最后一条指令是中断返回指令，选项Ⅱ错误。DMA接口（DMA控制器）负责数据的传输工作，不需要CPU控制，选项Ⅲ错误。DMA方式的数据传输完全由硬件（DMA控制器）实现，选项IV错误。</p>",
        "fromSchool": "25王道8套",
        "examTime": "2024年",
        "examCode": "408",
        "examFullName": "计算机学科基础综合（七）",
        "exerciseNumber": 22,
        "totalScore": 2,
        "knowledgeTags": [
            "1215321602355634176"
        ]
    },
    {
        "exerciseType": "单选题",
        "stem": "<p>多用户系统有必要保证进程的独立性，保证操作系统本身的安全，但为了向用户提供更大的灵活性，应尽可能少地限制用户进程。在下面列出的各操作中，（）是必须加以保护的。</p>",
        "options": {
            "A": "<p>从内核态转换到用户态</p>",
            "B": "<p>从存放操作系统内核的空间读取数据</p>",
            "C": "<p>从存放操作系统内核的空间读取指令</p>",
            "D": "<p>打开定时器</p>"
        },
        "answer": "D",
        "analysis": "<p>本题考查用户态与核心态。</p><p>打开定时器属于时钟管理的内容，对时钟的操作必须加以保护，否则，一个用户进程可在时间片还未到之前就将时钟改回去，导致时间片永远不会用完，该用户进程就一直占用CPU，这显然不合理。从用户态到内核态是通过中断实现的，中断的处理过程很复杂，需要加以保护，但从内核态到用户态则不需要加以保护。读取操作系统内核的数据和指令是静态操作，显然无须加以保护。</p>",
        "fromSchool": "25王道8套",
        "examTime": "2024年",
        "examCode": "408",
        "examFullName": "计算机学科基础综合（七）",
        "exerciseNumber": 23,
        "totalScore": 2,
        "knowledgeTags": [
            "1219613394580283392"
        ]
    },
    {
        "exerciseType": "单选题",
        "stem": "<p>关于临界区问题的一个算法（假设只有进程 $\\mathbf{P}_0$ 和 $\\mathbf{P}_1$ 可能会进入该临界区）如下（i为0或1），该算法（）。</p><p>![image](https://s3.hi168.com/hi168-26998-7111ilq6/exercises/e37098f1632306f32aacac4fa9e614c85fa0092e892574c9a2c5e6d26e2b785a-1771687985622.jpg)</p><p>临界区</p><p>![image](https://s3.hi168.com/hi168-26998-7111ilq6/exercises/0416e6578ed5059e139860c95a7b3db1461f827e01d68a5717d5debeeda7bc7f-1771687994345.jpg)</p><p>剩余区</p><p>until false;</p>",
        "options": {
            "A": "<p>不能保证进程互斥进入临界区, 且会出现 “饥饿”</p>",
            "B": "<p>不能保证进程互斥进入临界区, 但不会出现 “饥饿”</p>",
            "C": "<p>保证进程互斥进入临界区, 但会出现 “饥饿”</p>",
            "D": "<p>保证进程互斥进入临界区, 不会出现 “饥饿”</p>"
        },
        "answer": "B",
        "analysis": "<p>本题考查进程的同步与互斥。</p><p>进程 $\\mathbf{P}_0$ 和 $\\mathbf{P}_1$ 写为</p><p>$\\mathbf{P}_0$ ： $①$ if $(\\mathrm{turn}! = -1)$ turn=0; $\\mathbf{P}_1$ ： $④$ if $(\\mathrm{turn}! = -1)$ turn=1;</p><p>$②$ if $(\\mathrm{turn}! = 0)$ goto retry; $⑤$ if $(\\mathrm{turn}! = 1)$ goto retry;</p><p>$③$ turn=-1; $⑥$ turn=-1;</p><p>当执行顺序为 1,2,4,5,3,6 时, $\\mathrm{P}_{0}$ 和 $\\mathrm{P}_{1}$ 将全部进入临界区, 不能保证进程互斥进入临界区。</p><p>有的同学认为这道题会产生饥饿，理由如下：</p><p>当 $\\mathrm{P}_{0}$ 执行完临界区时, $\\mathrm{CPU}$ 调度 $\\mathrm{P}_{1}$ 执行④。当顺序执行 $1, 4, (2, 1, 5, 4), (2, 1, 5, 4), \\cdots$ 时, $\\mathrm{P}_{0}$ 和 $\\mathrm{P}_{1}$ 进入无限等待, 即出现 “饥饿” 现象。</p><p>这是对饥饿概念不熟悉的表现。饥饿的定义是：等待时间给进程推进和响应带来明显影响，称为进程饥饿。当饥饿到一定程度的进程等待到即使完成也无实际意义时，称为饥饿死亡，简称饿死。</p><p>产生饥饿的主要原因是：在一个动态系统中，对于每类系统资源，操作系统需要确定一个分配策略，当多个进程同时申请某类资源时，由分配策略确定资源分配给进程的次序。</p><p>有时，资源分配策略可能是不公平的，即不能保证等待时间上界的存在。在这种情况下，即使系统没有发生死锁，某些进程也可会长时间等待。</p><p>在本题中, $\\mathrm{P}_{0}$ 和 $\\mathrm{P}_{1}$ 只有满足特定的某个序列才能达到 “饥饿” 的效果, 并不由资源分配策略本身的不公平造成, 而这两个进程代码表现出来的策略是公平的, 两个进程的地位也是平等的。满足上述条件的特定序列具有特殊性, 对进程推进的不确定性而言, 是基本不可能出现这种巧合的。否则, 几乎所有这类进程就都可能产生饥饿。</p>",
        "fromSchool": "25王道8套",
        "examTime": "2024年",
        "examCode": "408",
        "examFullName": "计算机学科基础综合（七）",
        "exerciseNumber": 24,
        "totalScore": 2,
        "knowledgeTags": [
            "1219654958736220160"
        ]
    },
    {
        "exerciseType": "单选题",
        "stem": "<p>当利用银行家算法进行安全序列检查时，不需要的参数是（）。</p>",
        "options": {
            "A": "<p>系统资源总数</p>",
            "B": "<p>满足系统安全的最少资源数</p>",
            "C": "<p>用户最大需求数</p>",
            "D": "<p>用户已占有的资源数</p>"
        },
        "answer": "B",
        "analysis": "<p>本题考查银行家算法。</p><p>安全性检查一般要用到进程所需的最大资源数减去进程占用的资源数，得到进程为满足进程运行尚需的可能最大资源数，而系统拥有的最大资源数减去已分配的资源数，得到剩余的资源数，比较剩余的资源数是否满足进程运行尚需的可能最大资源数，就可得到当前状态是否安全的结论。因此，并无“满足系统安全的最少资源数”这种说法。</p>",
        "fromSchool": "25王道8套",
        "examTime": "2024年",
        "examCode": "408",
        "examFullName": "计算机学科基础综合（七）",
        "exerciseNumber": 25,
        "totalScore": 2,
        "knowledgeTags": [
            "1219658443221377024"
        ]
    },
    {
        "exerciseType": "单选题",
        "stem": "<p>设 $m$ 为同类资源数， $n$ 为系统中的并发进程数。当 $n$ 个进程共享 $m$ 个互斥资源时，每个进程的最大需求是 $w$ ，则在下列情况中，会出现系统死锁的是（）。</p>",
        "options": {
            "A": "<p>$m = 2, n = 1, w = 2$</p>",
            "B": "<p>$m = 2, n = 2, w = 1$</p>",
            "C": "<p>$m = 4, n = 3, w = 2$</p>",
            "D": "<p>$m = 4, n = 2, w = 3$</p>"
        },
        "answer": "D",
        "analysis": "<p>本题考查死锁的检测。</p><p>选项A不发生死锁，只有一个进程怎么也不发生死锁。选项B不发生死锁，两个进程各需要一个资源，而系统中刚好有2个资源。选项C不发生死锁，3个进程需要的最多资源数都是2，</p><p>所以总有一个进程得到 2 个资源，运行完毕后释放资源。选项 D 可能发生死锁，2 个进程各自都占有 2 个资源后，系统再无可分配资源。由此，可得出结论：满足 $m \\geq n(w - 1) + 1$ 时，不发生死锁。</p>",
        "fromSchool": "25王道8套",
        "examTime": "2024年",
        "examCode": "408",
        "examFullName": "计算机学科基础综合（七）",
        "exerciseNumber": 26,
        "totalScore": 2,
        "knowledgeTags": [
            "1219658443221377024"
        ]
    },
    {
        "exerciseType": "单选题",
        "stem": "<p>支持程序存放在不连续内存中的存储管理方法有（）。</p><p>I. 动态分区分配</p><p>II. 固定分区分配</p><p>III. 分页式分配</p><p>IV. 段页式分配</p><p>V. 分段式分配</p>",
        "options": {
            "A": "<p>I 和 II</p>",
            "B": "<p>III 和 IV</p>",
            "C": "<p>III、IV和V</p>",
            "D": "<p>I、III、IV和V</p>"
        },
        "answer": "C",
        "analysis": "<p>本题考查非连续分配管理方式。</p><p>非连续分配允许一个程序分散地装入不相邻的内存分区。动态分区分配和固定分区分配都属于连续分配方式，而非连续分配有分页式分配、分段式分配和段页式分配三种。</p>",
        "fromSchool": "25王道8套",
        "examTime": "2024年",
        "examCode": "408",
        "examFullName": "计算机学科基础综合（七）",
        "exerciseNumber": 27,
        "totalScore": 2,
        "knowledgeTags": [
            "1219660307522396160"
        ]
    },
    {
        "exerciseType": "单选题",
        "stem": "<p>在一个请求分页系统中，当采用LRU页面置换算法时，假设一个作业的页面走向为1,3,2,1,1,3,5,1,3,2,1,5。当分配给该作业的物理块数分别为3和4时，在访问过程中发生的缺页率分别为（）。</p>",
        "options": {
            "A": "<p>$50\\%$ 和 $33\\%$</p>",
            "B": "<p>$25\\%$ 和 $100\\%$</p>",
            "C": "<p>$25\\%$ 和 $33\\%$</p>",
            "D": "<p>$50\\%$ 和 $75\\%$</p>"
        },
        "answer": "A",
        "analysis": "<p>本题考查页面置换的相关计算。</p><p>当物理块数为3时，缺页情况如下表所示。缺页次数为6，缺页率为 $6 / 12 = 50\\%$ 。</p><table><tr><td>访问串</td><td>1</td><td>3</td><td>2</td><td>1</td><td>1</td><td>3</td><td>5</td><td>1</td><td>3</td><td>2</td><td>1</td><td>5</td></tr><tr><td rowspan=\"3\">内存</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td></td><td>3</td><td>3</td><td>3</td><td>3</td><td>3</td><td>3</td><td>3</td><td>3</td><td>3</td><td>3</td><td>5</td></tr><tr><td></td><td></td><td>2</td><td>2</td><td>2</td><td>2</td><td>5</td><td>5</td><td>5</td><td>2</td><td>2</td><td>2</td></tr><tr><td>缺页</td><td>✓</td><td>✓</td><td>✓</td><td></td><td></td><td></td><td>✓</td><td></td><td></td><td>✓</td><td></td><td>✓</td></tr></table><p>当物理块数为4时，缺页情况如下表所示。缺页次数为4，缺页率为 $4 / 12\\approx 33\\%$</p><table><tr><td>访问串</td><td>1</td><td>3</td><td>2</td><td>1</td><td>1</td><td>3</td><td>5</td><td>1</td><td>3</td><td>2</td><td>1</td><td>5</td></tr><tr><td rowspan=\"4\">内存</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td></td><td>3</td><td>3</td><td>3</td><td>3</td><td>3</td><td>3</td><td>3</td><td>3</td><td>3</td><td>3</td><td>3</td></tr><tr><td></td><td></td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td>5</td><td>5</td><td>5</td><td>5</td><td>5</td><td>5</td></tr><tr><td>缺页</td><td>✓</td><td>✓</td><td>✓</td><td></td><td></td><td></td><td>✓</td><td></td><td></td><td></td><td></td><td></td></tr></table><p>▲注意，当分配给作业的物理块数为4时，作业请求页面序列只有4个页面，可以直接得出缺页次数为4，而不需要按表中所示的那样列出缺页情况。</p>",
        "fromSchool": "25王道8套",
        "examTime": "2024年",
        "examCode": "408",
        "examFullName": "计算机学科基础综合（七）",
        "exerciseNumber": 28,
        "totalScore": 2,
        "knowledgeTags": [
            "1219663653297725440"
        ]
    },
    {
        "exerciseType": "单选题",
        "stem": "<p>在下列关于文件系统的说法中，正确的是（）。</p>",
        "options": {
            "A": "<p>文件系统负责文件存储空间的管理，但不能实现文件名到物理地址的转换</p>",
            "B": "<p>在多级目录结构中，对文件的访问是通过路径名和用户目录名进行的</p>",
            "C": "<p>文件可以被划分成大小相等的若干物理块, 且物理块大小可任意指定</p>",
            "D": "<p>逻辑记录是对文件进行存取操作的基本单位</p>"
        },
        "answer": "D",
        "analysis": "<p>本题考查文件系统的多个知识点。</p><p>文件系统使用文件名进行管理，实现了文件名到物理地址的转换，选项A错误。在多级目录结构中，从根目录到任何数据文件都只有唯一一条路径，该路径从树根开始，将全部目录文件名和文件名依次用“/”连接起来，构成该数据文件的路径名。选项B的说法不准确，对文件的访问只需通过路径名即可。文件被划分的物理块的大小是固定的，通常和内存管理中的页面大小一致，选项C错误。逻辑记录是文件按信息逻辑独立的含义来划分的信息单位，它是对文件进行存取操作的基本单位，选项D正确。</p>",
        "fromSchool": "25王道8套",
        "examTime": "2024年",
        "examCode": "408",
        "examFullName": "计算机学科基础综合（七）",
        "exerciseNumber": 29,
        "totalScore": 2,
        "knowledgeTags": [
            "1219670672268337152"
        ]
    },
    {
        "exerciseType": "单选题",
        "stem": "<p>在某个文件系统中，每个盘块的大小为 512B，文件控制块占 64B，其中文件名占 6B。若索引节点编号占 2B，对一个存放在磁盘上的 256 个目录项的目录，试比较引入索引节点前后，为了找到其中一个文件的 FCB，平均启动磁盘的次数减少了（）次。</p>",
        "options": {
            "A": "<p>4.5</p>",
            "B": "<p>8.5</p>",
            "C": "<p>13</p>",
            "D": "<p>16.5</p>"
        },
        "answer": "C",
        "analysis": "<p>本题考查文件控制块和索引节点。</p><p>引入索引节点前，每个目录项中存放的是对应文件的FCB，256个目录项的目录共需占用 $256\\times 64 / 512 = 32$ 个盘块，因此在该目录中检索一个文件时，平均启动磁盘的次数为 $(1 + 32) / 2 =$ 16.5次。引入索引节点后，每个目录项中只需存放文件名和索引节点编号，256个目录项的目录共需占用 $256\\times (6 + 2) / 512 = 4$ 个盘块，因此找到匹配的目录项平均需要启动 $(1 + 4) / 2 = 2.5$ 次磁盘，得到索引节点编号后，还需启动磁盘将对应文件的索引节点读入内存，因此平均需要启动磁盘3.5次。可见，平均启动磁盘的次数减少了13次。</p>",
        "fromSchool": "25王道8套",
        "examTime": "2024年",
        "examCode": "408",
        "examFullName": "计算机学科基础综合（七）",
        "exerciseNumber": 30,
        "totalScore": 2,
        "knowledgeTags": [
            "1219670672268337152"
        ]
    },
    {
        "exerciseType": "单选题",
        "stem": "<p>在下列关于设备独立性的论述中，正确的是（）。</p>",
        "options": {
            "A": "<p>设备独立性是 I/O 设备具有独立执行 I/O 功能的一种特性</p>",
            "B": "<p>设备独立性是指用户程序独立于具体使用的物理设备的一种特性</p>",
            "C": "<p>设备独立性是指独立实现设备共享的一种特性</p>",
            "D": "<p>设备独立性是指设备驱动独立于具体使用的物理设备的一种特性</p>"
        },
        "answer": "B",
        "analysis": "<p>本题考查设备独立性的定义。</p><p>设备独立性是指用户程序独立于具体物理设备的一种特性，引入设备的独立性是为了提高设备分配的灵活性和设备的利用率等。</p>",
        "fromSchool": "25王道8套",
        "examTime": "2024年",
        "examCode": "408",
        "examFullName": "计算机学科基础综合（七）",
        "exerciseNumber": 31,
        "totalScore": 2,
        "knowledgeTags": [
            "1219676230845210624"
        ]
    },
    {
        "exerciseType": "单选题",
        "stem": "<p>在下列关于固态硬盘 SSD 的说法中，正确的是（）。</p>",
        "options": {
            "A": "<p>固态硬盘属于磁表面存储器</p>",
            "B": "<p>固态硬盘的闪存翻译层相当于磁盘中的磁盘控制器, 起到地址转换的作用</p>",
            "C": "<p>固态硬盘的随机读时延远低于常规硬盘, 但随机写时延和常规硬盘的相差不大</p>",
            "D": "<p>在对固态硬盘的某块写入信息时, 不必按照块内页的顺序写入信息</p>"
        },
        "answer": "B",
        "analysis": "<p>本题考查固态硬盘（SSD）的性质。</p><p>固态硬盘基于闪存技术，不属于磁表面存储器，选项A错误。闪存翻译层可将CPU的逻辑磁盘块读/写请求转化为对底层SSD物理设备的读/写控制信号，选项B正确。固态硬盘无论是读还是写，速度都远快于常规硬盘，选项C错误。固态硬盘块内的页必须按顺序写入信息，选项D错误。</p>",
        "fromSchool": "25王道8套",
        "examTime": "2024年",
        "examCode": "408",
        "examFullName": "计算机学科基础综合（七）",
        "exerciseNumber": 32,
        "totalScore": 2,
        "knowledgeTags": [
            "1219680830126039040"
        ]
    },
    {
        "exerciseType": "单选题",
        "stem": "<p>正确描述网络体系结构中的分层概念的是（）。</p>",
        "options": {
            "A": "<p>保持网络灵活且易于修改</p>",
            "B": "<p>所有的网络体系结构都使用相同的层次名称和功能</p>",
            "C": "<p>把相关的网络功能组合在一层中</p>",
            "D": "<p>定义各层的功能以及功能的具体实现</p>"
        },
        "answer": "A",
        "analysis": "<p>本题考查网络体系结构的原则和特点。</p><p>网络体系结构是抽象的，它不包括各层协议及功能的具体实现细节。若规定层的名称和功能，则难以保持网络的灵活性。分层使得各层之间相对独立，各层仅需关注该层需要完成的功能，保持了网络的灵活性和封装性，但网络的体系结构并未规定层的名称和功能必须一致，选项A正确；不同的网络体系结构划分出的结构不尽相同，如OSI参考模型与TCP/IP模型就不尽相同，选项B错误；分层应划分网络的功能，而不将相关的网络功能组合到一层中，选项C错误；分层不涉及具体功能的实现，选项D错误。</p>",
        "fromSchool": "25王道8套",
        "examTime": "2024年",
        "examCode": "408",
        "examFullName": "计算机学科基础综合（七）",
        "exerciseNumber": 33,
        "totalScore": 2,
        "knowledgeTags": [
            "1220671115861696512"
        ]
    },
    {
        "exerciseType": "单选题",
        "stem": "<p>主机收到的海明码序列为 101 1101 0011 1011（从右向左编号，右边为最低位），有效数据为 11 位，经过检测发现了差错，则错误的位置是（）。</p>",
        "options": {
            "A": "<p>第1位</p>",
            "B": "<p>第2位</p>",
            "C": "<p>第4位</p>",
            "D": "<p>第8位</p>"
        },
        "answer": "D",
        "analysis": "<p>本题考查海明码的检验过程。</p><p>有效数据位为 11 位; 检验位为 4 位, 分布在从右往左的第 1,2,4,8 位。每个检验组分别利用检验位和参与形成该检验位的信息位进行奇偶检验检查, 构成 4 个检验方程, 其中 $S_{1} = 1 \\oplus 0 \\oplus 1 \\oplus 0 \\oplus 1 \\oplus 1 \\oplus 1 = 0$ , $S_{2} = 1 \\oplus 0 \\oplus 1 \\oplus 0 \\oplus 0 \\oplus 1 \\oplus 0 \\oplus 1 = 0$ , $S_{3} = 1 \\oplus 1 \\oplus 1 \\oplus 0 \\oplus 1 \\oplus 1 \\oplus 0 \\oplus 1 = 0$ , $S_{4} = 1 \\oplus 0 \\oplus 1 \\oplus 1 \\oplus 1 \\oplus 0 \\oplus 1 \\oplus 0 = 1$ , 因此 $S_{4} S_{3} S_{2} S_{1} = 1000$ , 表示第 8 位发生了错误。</p>",
        "fromSchool": "25王道8套",
        "examTime": "2024年",
        "examCode": "408",
        "examFullName": "计算机学科基础综合（七）",
        "exerciseNumber": 34,
        "totalScore": 2,
        "knowledgeTags": [
            "1215241761115611136"
        ]
    },
    {
        "exerciseType": "单选题",
        "stem": "<p>一个 $2\\mathrm{Mb/s}$ 的网络，线路长度为 $1\\mathrm{km}$ ，传输速度为 $20\\mathrm{m/ms}$ ，分组大小为 $100\\mathrm{B}$ ，应答帧大小可以忽略。若采用“停止-等待”协议，则实际数据率是（）。</p>",
        "options": {
            "A": "<p>$2 \\mathrm{Mb} / \\mathrm{s}$</p>",
            "B": "<p>$1 \\mathrm{M} \\mathrm{b} / \\mathrm{s}$</p>",
            "C": "<p>$8 \\mathrm{~kb} / \\mathrm{s}$</p>",
            "D": "<p>$16 \\mathrm{~kb} / \\mathrm{s}$</p>"
        },
        "answer": "C",
        "analysis": "<p>本题考查“停止-等待”协议的效率分析。</p><p>停止-等待协议发送一个分组后，需要收到确认后才能发送下一个分组。发送延迟 $= 8\\mathrm{bit} \\times 100 / (2 \\times 1000000\\mathrm{b / s}) = 0.0004\\mathrm{s}$ ，传播延迟 $= 1000\\mathrm{m / (20m / ms)} = 50\\mathrm{ms} = 0.05\\mathrm{s}$ ，最小间隔 $= 0.0004\\mathrm{s} + 0.05\\mathrm{s} \\times 2 = 0.1004\\mathrm{s}$ 。因此，数据率 $= 8 \\times 100\\mathrm{bit / 0.1004s} \\approx 8\\mathrm{kb / s}$ 。</p>",
        "fromSchool": "25王道8套",
        "examTime": "2024年",
        "examCode": "408",
        "examFullName": "计算机学科基础综合（七）",
        "exerciseNumber": 35,
        "totalScore": 2,
        "knowledgeTags": [
            "1220674454670286848"
        ]
    },
    {
        "exerciseType": "单选题",
        "stem": "<p>以太网交换机的自学习算法是指，它根据帧中的（）进行地址学习。</p>",
        "options": {
            "A": "<p>源 MAC 地址</p>",
            "B": "<p>目的 MAC 地址</p>",
            "C": "<p>源 MAC 地址和目的 MAC 地址</p>",
            "D": "<p>源IP地址</p>"
        },
        "answer": "A",
        "analysis": "<p>本题考查交换机的特性。</p><p>交换机是二层设备，看不到 IP 地址，选项 D 错误。交换机收到一个帧时，只有源主机的方向是确定的，目的主机往哪个方向转发不一定知道（除非表项中有目的 MAC，此时也不用将目的 MAC 添加到表项中），因此将源 MAC 地址加入表项（如果本来不在其中的话），这就是交换机的自学习，因此选择选项 A。</p>",
        "fromSchool": "25王道8套",
        "examTime": "2024年",
        "examCode": "408",
        "examFullName": "计算机学科基础综合（七）",
        "exerciseNumber": 36,
        "totalScore": 2,
        "knowledgeTags": [
            "1220677514696073216"
        ]
    },
    {
        "exerciseType": "单选题",
        "stem": "<p>若子网掩码是 255.255.192.0，则在下列主机中，必须通过路由器才能与主机 129.23.144.16 通信的是（）。</p>",
        "options": {
            "A": "<p>129.23.191.21</p>",
            "B": "<p>129.23.127.222</p>",
            "C": "<p>129.23.130.33</p>",
            "D": "<p>129.23.148.127</p>"
        },
        "answer": "B",
        "analysis": "<p>本题考查子网划分与子网掩码。</p><p>不同子网之间需通过路由器相连，子网内的通信则不需要经过路由器转发，因此比较各主机的子网号即可。将子网掩码255.255.192.0与主机129.23.144.16进行“与”操作，得到该主机网络的地址为129.23.128.0，再将该子网掩码分别与四个候选答案的地址进行“与”操作，只有129.23.127.222的网络地址不为129.23.128.0。因此该主机与129.23.144.16不在一个子网中，需要通过路由器转发信息。</p><p>▲注意：回答这种题时，要将用到的十进制数转换为二进制数，而不能凭感觉来做选择，否则容易导致错误。</p>",
        "fromSchool": "25王道8套",
        "examTime": "2024年",
        "examCode": "408",
        "examFullName": "计算机学科基础综合（七）",
        "exerciseNumber": 37,
        "totalScore": 2,
        "knowledgeTags": [
            "1220681307722620928"
        ]
    },
    {
        "exerciseType": "单选题",
        "stem": "<p>IP多播地址226.0.9.26和226.128.9.26转换成的以太网硬件多播地址分别是（）。</p>",
        "options": {
            "A": "<p>00-00-5E-00-00-00 和 00-00-5E-7F-FF-FF</p>",
            "B": "<p>01-00-5E-00-09-26 和 01-00-5E-10-09-26</p>",
            "C": "<p>01-00-5E-00-09-1A 和 01-00-5E-00-09-1A</p>",
            "D": "<p>00-00-5E-7F-FF-FF 和 00-00-5E-00-00-00</p>"
        },
        "answer": "C",
        "analysis": "<p>本题考查 IP 多播地址。</p><p>当 IP 多播地址转化为以太网的硬件多播地址时，只有后 23 位映射到 MAC 地址，硬件多播地址的前 25 位是固定的，为 000000010000000001011100，因此选择选项 C。</p>",
        "fromSchool": "25王道8套",
        "examTime": "2024年",
        "examCode": "408",
        "examFullName": "计算机学科基础综合（七）",
        "exerciseNumber": 38,
        "totalScore": 2,
        "knowledgeTags": [
            "1220693557019680768"
        ]
    },
    {
        "exerciseType": "单选题",
        "stem": "<p>第一次传输时，设TCP的拥塞窗口的慢启动门限初始值为8（单位为报文段），拥塞窗口上升到12时，网络发生超时，TCP开始慢启动和拥塞避免，第12次传输时拥塞窗口的大小为（）。</p>",
        "options": {
            "A": "<p>5</p>",
            "B": "<p>6</p>",
            "C": "<p>7</p>",
            "D": "<p>8</p>"
        },
        "answer": "B",
        "analysis": "<p>本题考查 TCP 的拥塞控制。</p><p>此类题往往综合四种拥塞控制算法，解题时要么画出拥塞窗口变化曲线图，要么列出拥塞窗口大小变化序列，尤其要注意拐点处的变化情况。在慢启动和拥塞避免算法中，拥塞窗口的初始值为1，窗口大小开始按指数增长。当拥塞窗口大于慢启动门限后，停止使用慢启动算法，改用拥塞避免算法。此时，慢启动的初始门限值为8，当拥塞窗口增大到8时，改用拥塞避免算法，窗口大小按线性增长，每次增长1个报文段。当增加到12时，出现超时，重新设置门限值</p><p>为 6 (12 的一半), 拥塞窗口再重新设为 1 , 执行慢启动算法, 到门限值为 6 时, 执行拥塞避免算法。按照上面的算法, 拥塞窗口的变化为 $1, 2, 4, 8, 9, 10, 11, 12, 1, 2, 4, 6, 7, 8, 9, \\cdots$ , 从该序列可以看出, 第 12 次传输时拥塞窗口大小为 6 。</p><p>▲注意: 很多考生误选选项 D, 原因是直接在以上序列中从 4 增加到 8 。拥塞窗口的大小和门限值有关, 在慢开始算法中不能直接变化为大于门限值, 所以 4 最多只能增加到 6 , 之后执行拥塞避免算法。</p>",
        "fromSchool": "25王道8套",
        "examTime": "2024年",
        "examCode": "408",
        "examFullName": "计算机学科基础综合（七）",
        "exerciseNumber": 39,
        "totalScore": 2,
        "knowledgeTags": [
            "1220695627089059840"
        ]
    },
    {
        "exerciseType": "单选题",
        "stem": "<p>某同学在校园网访问因特网，在从该同学打开计算机电源到使用命令 ftp 连通到文件服务器 202.38.70.25 的过程中，（）协议可能未用到。</p>",
        "options": {
            "A": "<p>IP</p>",
            "B": "<p>ICMP</p>",
            "C": "<p>ARP</p>",
            "D": "<p>DHCP</p><p># 二、综合应用题</p><p>第 $41\\sim 47$ 题，共70分。</p>"
        },
        "answer": "B",
        "analysis": "<p>本题考查各种协议的应用。</p><p>刚开机时 ARP 表为空，当需要和其他主机通信时，数据链路层需要使用 MAC 地址，因此要用到 ARP 协议。通过校园网访问因特网时，肯定要用到 IP。因为此时访问的是因特网，因特网为外网，所以需要通过 DHCP 分配公网地址。ICMP 主要用于发送 ICMP 差错报告报文和 ICMP 询问报文，因此不一定用到。</p><p># 二、综合应用题</p>",
        "fromSchool": "25王道8套",
        "examTime": "2024年",
        "examCode": "408",
        "examFullName": "计算机学科基础综合（七）",
        "exerciseNumber": 40,
        "totalScore": 2,
        "knowledgeTags": [
            "1220671004674891776"
        ]
    },
    {
        "exerciseType": "解答题",
        "stem": "<p>（10分）输入关键字序列15, 10, 24, 47, 37, 68, 50，建立大根堆，回答下列问题。</p>",
        "options": [
            {
                "questionOrder": 1,
                "questionStem": "<p>堆是顺序存储的还是非顺序存储的？</p>",
                "questionAnswer": "<p>顺序存储。</p><p>注意：看上去，堆的每个结点都有左子树和右子树，且经常需要与它们交换，但实际上是采用顺序表保存的，类似于完全二叉树的顺序表保存，结点编号就是其在数组中的位置。</p>",
                "questionAnalysis": null,
                "questionScore": 0
            },
            {
                "questionOrder": 2,
                "questionStem": "<p>使用C或 $\\mathbf{C} + +$ 语言，给出堆的数据结构定义。</p>",
                "questionAnswer": "<p>堆的数据结构定义如下：</p><p>```txt</p><p>struct Heap {</p><p>ElementType data[Maxsize]; //存储元素的数组</p><p>int size; //堆中元素个数</p><p>};</p><p>```</p><p>其他写法（简单写法）：</p><p>```txt</p><p>int data [Maxsize]; //使用data[0]来保存堆中的元素个数</p><p>```</p>",
                "questionAnalysis": null,
                "questionScore": 0
            },
            {
                "questionOrder": 3,
                "questionStem": "<p>画图模拟大根堆的建堆过程。</p>",
                "questionAnswer": "<p>堆中的元素有 7 个, 从第 $7 / 2 = 3$ 个开始元素为根的子树开始处理, 先处理 3 号元素 24 ,发现比 68 小, 交换 24 和 68 ; 然后处理 2 号元素 10 , 发现比 47 小, 交换 10 和 47 ; 再后处理 1 号元素 15 , 发现比 68 小, 15 和 68 交换; 因为 3 号元素与 1 号元素交换, 破坏了以 3 号元素为根的子树的堆性质, 所以再从 3 号元素向下判断, 发现 3 号元素 15 比 50 小, 交换 15 和 50 , 此时不需要再向上判断。建堆过程如下图所示。</p><p>![image](https://s3.hi168.com/hi168-26998-7111ilq6/exercises/0b8b28093c25f83b29ddc91920b790214e7faefe85bbb1b48b5758160aab46f3-1771687961155.jpg)</p>",
                "questionAnalysis": null,
                "questionScore": 0
            }
        ],
        "fromSchool": "25王道8套",
        "examTime": "2024年",
        "examCode": "408",
        "examFullName": "计算机学科基础综合（七）",
        "exerciseNumber": 41,
        "totalScore": 10,
        "knowledgeTags": [
            "1218133293095198720",
            "1218134865606877184"
        ]
    },
    {
        "exerciseType": "解答题",
        "stem": "<p>（13分）设树 $T$ 采用孩子兄弟链表表示（数据域、孩子域、兄弟域），设计算法计算树 $T$ 的度。</p>",
        "options": [
            {
                "questionOrder": 1,
                "questionStem": "<p>写出树结点的数据结构定义。</p>",
                "questionAnswer": "<p>定义如下：</p><p>```txt</p><p>typedef struct node{ int data; struct node \\*firstchild, \\*nextbro; }TNode;</p><p>```</p>",
                "questionAnalysis": null,
                "questionScore": 0
            },
            {
                "questionOrder": 2,
                "questionStem": "<p>给出算法的基本设计思想。</p>",
                "questionAnswer": "<p>结点 $p$ 的度 $= 1 + p$ 的第一个左孩子后面的兄弟数, 对树进行后根遍历, 往 firstchild 域递归, 度 $d$ 不变, 往 nextbro 域递归, 度 $d = d + 1$ , 求出每个结点后面的兄弟有多少个, 即可求出所有结点的度,</p>",
                "questionAnalysis": null,
                "questionScore": 0
            },
            {
                "questionOrder": 3,
                "questionStem": "<p>根据设计思想，采用C或 $\\mathrm{C + + }$ 语言描述算法，关键之处给出注释。</p>",
                "questionAnswer": "<p>算法的代码如下：</p><p>int degree $= 0$ //全局变量，最终输出degree</p><p>int Post(TNode\\*p){ //后序遍历if $(\\mathfrak{p} = =\\mathbb{N}$ ULL) return 0; //该结点不存在Post(p->firstchild); int d=1+Post(p->nextbro); degree=max(degree,d); return d;</p>",
                "questionAnalysis": null,
                "questionScore": 0
            }
        ],
        "fromSchool": "25王道8套",
        "examTime": "2024年",
        "examCode": "408",
        "examFullName": "计算机学科基础综合（七）",
        "exerciseNumber": 42,
        "totalScore": 13,
        "knowledgeTags": [
            "1217891043161415680",
            "1217891098253598720",
            "1217891265379835904"
        ]
    },
    {
        "exerciseType": "解答题",
        "stem": "<p>（11分）通过对方格中的每个点设置相应的CMYK值，可以在该方格内涂上相应的颜色。下图所示的三个程序段都可将一个 $8\\times 8$ 的方格涂上黄色。</p><table><tr><td>struct pt_color {<p>int c;</p><p>int m;</p><p>int y;</p><p>int k;</p><p>}</td><td>struct pt_color {</p><p>int C;</p><p>int m;</p><p>int y;</p><p>int k;</td><td>struct pt_color {</p><p>int c;</p><p>int m;</p><p>int y;</p><p>int k;</td></tr><tr><td>struct pt_color square[8][8];</p><p>int i, j;</p><p>for (i=0; i&lt;8; i++) {</p><p>for (j=0; j&lt;8; j++) {</p><p>square[i][j].c=0;</p><p>square[i][j].m=0;</p><p>square[i][j].y=1;</p><p>square[i][j].k=0;</p><p>}</td><td>struct pt_color square[8][8];</p><p>int i, j;</p><p>for (i=0; i&lt;8; i++) {</p><p>for (j=0; j&lt;8; j++) {</p><p>square[j][i].c=0;</p><p>square[j][i].m=0;</p><p>square[j][i].y=1;</p><p>square[j][i].k=0;</td><td>struct pt_color square[8][8];</p><p>int i, j;</p><p>for (i=0; i&lt;8; i++) {</p><p>for (j=0; j&lt;8; j++) {</p><p>square[i][j].y=1;</p><p>for (i=0; i&lt;8; i++) {</p><p>square[i][j].m=0;</p><p>square[i][j].k=0;</td></tr></table></p><p>(a) 程序段A</p><p>(b) 程序段 B</p><p>(c) 程序段 C</p><p>假设 Cache 的数据区大小为 512B，采用直接映射，块大小为 32B，存储器按字节编址，sizeof(int) = 4。编译时变量 i 和 j 分配在寄存器中，数组 square 按行优先存储在 0000OC80H 开始的连续主存区域中，主存地址为 32 位，回答下列问题。</p>",
        "options": [
            {
                "questionOrder": 1,
                "questionStem": "<p>分析并比较程序段A、B、C中数组访问的时间局部性和空间局部性。</p>",
                "questionAnswer": "<p>在程序段 A、B 和 C 中, 每个数组元素都只被访问一次, 都没有时间局部性; 程序段 A 的访问顺序和存放顺序一致, 空间局部性好; 程序段 B 的访问顺序和存放顺序不一致, 空间局部性不好; 程序段 C 的访问顺序和存放顺序部分一致, 空间局部性的优劣介于程序段 A 和 B 之间。</p>",
                "questionAnalysis": null,
                "questionScore": 0
            },
            {
                "questionOrder": 2,
                "questionStem": "<p>一个Cache行中能存放几个square数组元素？整个数组共占用几个主存块？第一个数组元素位于主存的第几块中？映射到Cache的第几行？</p>",
                "questionAnswer": "<p>一个数组元素占 $4 \\times 4\\mathrm{B} = 16\\mathrm{B}$ , 每个块 (或 Cache 行) 能存放 2 个数组元素。 $8 \\times 8$ 的数组共占 32 个主存块, 正好是 Cache 数据区大小的 2 倍。数组 square 的首地址为 $00000\\mathrm{C}80\\mathrm{H} = 0\\dots 0$ 110010000000B, 最低 5 位为全 0 , 表示主存第 1100100B 块的起始地址, 因此第一个数组元素位于主存的第 100 块。Cache 行数为 $512\\mathrm{B} / 32\\mathrm{B} = 16, 100 \\mod 16 = 4$ , 所以主存第 100 块映射到的 Cache 行号为 4 。主存中的数组元素与 Cache 行的映射关系如下图所示。</p><p>![image](https://s3.hi168.com/hi168-26998-7111ilq6/exercises/b8a1e658bfdfe199c3a43551dfc733e0ad74222cab76ec5b0ac2e40f7d03ff2a-1771687991367.jpg)</p>",
                "questionAnalysis": null,
                "questionScore": 0
            },
            {
                "questionOrder": 3,
                "questionStem": "<p>试计算三个程序段A、B、C中数组访问的写操作次数、写不命中次数和写缺失率。</p>",
                "questionAnswer": "<p>程序段A：每2个数组元素（共涉及8次写操作）装入一个Cache行，总是第1次不命中，后面7次都命中，总写操作次数为 $64 \\times 4 = 256$ ，写不命中次数为 $256 \\times 1 / 8 = 32$ ，写缺失率为 $12.5\\%$ 。</p><p>程序段 B: 每 2 个数组元素（共 8 次写操作）装入一个 Cache 行，总是只有 1 个数组元素（共 4 次写操作）在被淘汰前访问，且总是第 1 次不命中，后面 3 次都命中，写不命中次数为 $256 \\times 1 / 4 = 64$ ，写缺失率为 $25\\%$ 。</p><p>程序段 C: 第一个循环共访问 64 次, 每次装入 2 个数组元素, 第一次不命中, 第二次命</p><p>中；第二个循环共访问 $64 \\times 3$ 次，每2个数组元素（共涉及6次写操作）装入一个Cache行，且总是第1次不命中，后面5次都命中，写不命中次数为 $32 + (3 \\times</p>",
                "questionAnalysis": null,
                "questionScore": 0
            }
        ],
        "fromSchool": "25王道8套",
        "examTime": "2024年",
        "examCode": "408",
        "examFullName": "计算机学科基础综合（七）",
        "exerciseNumber": 43,
        "totalScore": 11,
        "knowledgeTags": [
            "1215246689913544704",
            "1215247328999645184",
            "1215253423168167936"
        ]
    },
    {
        "exerciseType": "解答题",
        "stem": "<p>（12分）某C程序中包含代码“for $(i = 0;i < 5;i++)$ $j = j + B[i]$ ；”，假设编译时变量i、j分别保存在寄存器R1和R2中，int型数组B的首地址分配在寄存器R3中，该段代码对应的汇编程序和机器代码如下表所示。</p><table><tr><td>编 号</td><td>地 址</td><td>机器代码</td><td>汇编代码</td><td>注 释</td></tr><tr><td>1</td><td>00003000H</td><td>00000820H</td><td>add R1, R0, R0</td><td>\\( 0 \\rightarrow  \\mathrm{R}1 \\)</td></tr><tr><td>2</td><td>00003004H</td><td>00012880H</td><td>sll R5, R1, 2</td><td>(R1) \\( &lt;  &lt; 2 \\rightarrow  \\mathrm{R}5 \\)</td></tr></table><p>续表</p><table><tr><td>编 号</td><td>地 址</td><td>机器代码</td><td>汇编代码</td><td>注 释</td></tr><tr><td>3</td><td>00003008H</td><td>00A32820H</td><td>add R5, R5, R3</td><td>\\( \\left( {\\mathrm{R}5}\\right)  + \\left( {\\mathrm{R}3}\\right)  \\rightarrow  \\mathrm{R}5 \\)</td></tr><tr><td>4</td><td>0000300CH</td><td>8CA60000H</td><td>lw R6, 0(R5)</td><td>\\( \\left( {\\left( {\\mathrm{R}5}\\right)  + 0}\\right)  \\rightarrow  \\mathrm{R}6 \\)</td></tr><tr><td>5</td><td>00003010H</td><td>00461020H</td><td>add R2, R2, R6</td><td>\\( \\left( {\\mathrm{R}2}\\right)  + \\left( {\\mathrm{R}6}\\right)  \\rightarrow  \\mathrm{R}2 \\)</td></tr><tr><td>6</td><td>00003014H</td><td>20210001H</td><td>add R1, R1, 1</td><td>\\( \\left( {\\mathrm{R}1}\\right)  + 1 \\rightarrow  \\mathrm{R}1 \\)</td></tr><tr><td>7</td><td>00003018H</td><td>28240005H</td><td>slt R4, R1, 5</td><td>if \\( \\left( {\\mathrm{R}1}\\right)  &lt; 5\\;1 \\rightarrow  \\mathrm{R}4 \\)</td></tr><tr><td>8</td><td>0000301CH</td><td>1480FFF9H</td><td>bne R4, R0, loop</td><td>if (R4) != 0 goto loop</td></tr></table><p>这段代码在某台主频为 $100\\mathrm{MHz}$ 且采用32位定长指令字的计算机上运行，其中的bne指令格式如下图所示。</p><table><tr><td colspan=\"4\">31 26 25 21 20 16 15 0</td></tr><tr><td>OP</td><td>Rs</td><td>Rt</td><td>OFFSET</td></tr></table><p>OP 为操作码，Rs 和 Rt 为寄存器编号，OFFSET 为偏移量，用补码表示。回答下列问题。</p>",
        "options": [
            {
                "questionOrder": 1,
                "questionStem": "<p>该计算机的CPU中包含多少个通用寄存器？存储器编址单位是多少？</p>",
                "questionAnswer": "<p>因为寄存器 R 是 5 位二进制, 所以有 $2^{5} = 32$ 个通用寄存器。因为一条指令 32 位, 占 4 个地址, 所以编址单位是 $32 \\mathrm{bit} / 4 = 8 \\mathrm{bit} = 1 \\mathrm{~B}$ 。</p>",
                "questionAnalysis": null,
                "questionScore": 0
            },
            {
                "questionOrder": 2,
                "questionStem": "<p>bne指令采用相对寻址，OFFSET部分存放的是字偏移量，给出指令中loop指向的地址。</p>",
                "questionAnswer": "<p>方法 1: 可以根据 C 语言代码判断 (比较简单): 第 1 条指令给 for 循环中的 i 赋初始值,之后的指令都是循环执行的, 所以 loop 指向第 2 条指令 (这条指令的含义是根据 i 的值求出相对于 B 首址的偏移), 地址为 $00003004 \\mathrm{H}$ 。</p><p>方法2：根据机器代码判断（较难）：查看bne指令格式，得到补码OFFSET = FFF9H，对应的有符号数真值为-7，因为是字偏移量且字长等于指令长度，所以相当于往前跳转了7条指令（PC在取指完自增后，应该从第9条指令开始向前跳转7条），即 $8 + 1 - 7 = 2$ ，loop指向第二条指令，地址为00003004H。</p>",
                "questionAnalysis": null,
                "questionScore": 0
            },
            {
                "questionOrder": 3,
                "questionStem": "<p>该计算机的各类指令所花费的时钟周期数如下：运算类指令4个，分支跳转类指令3个，访存类指令（可以包含计算）5个，计算该段代码的平均CPI、MIPS及总执行时间 $T$ 。</p>",
                "questionAnswer": "<p>+</p>",
                "questionAnalysis": null,
                "questionScore": 0
            },
            {
                "questionOrder": 4,
                "questionStem": "<p>若该计算机采用五级流水线，且硬件不使用任何转发措施，则bne指令的指向会引起2个时钟周期的阻塞。这段代码中哪些编号的指令执行会由于数据相关导致阻塞？哪些编号的指令执行会引起控制相关？</p>",
                "questionAnswer": "<p>指令 1 和 2、2 和 3、3 和 4、4 和 5、6 和 7、7 和 8 都会因为需要使用的寄存器还未被上一条指令写入造成的数据相关产生阻塞。分支跳转指令会产生控制相关, 所以指令 8 会产生控制相关。</p>",
                "questionAnalysis": null,
                "questionScore": 0
            }
        ],
        "fromSchool": "25王道8套",
        "examTime": "2024年",
        "examCode": "408",
        "examFullName": "计算机学科基础综合（七）",
        "exerciseNumber": 44,
        "totalScore": 12,
        "knowledgeTags": [
            "1215267009533845504",
            "1215267953801699328",
            "1215304376919531520"
        ]
    },
    {
        "exerciseType": "解答题",
        "stem": "<p>请回答下列问题。</p>",
        "options": [
            {
                "questionOrder": 1,
                "questionStem": "<p>（7分）有三个进程PA、PB和PC合作解决文件打印问题：PA将文件记录从磁盘读入主存的缓冲区1，每执行一次就读一条记录；PB将缓冲区1的内容复制到缓冲区2，每执行一次就复制一条记录；PC将缓冲区2的内容打印出来，每执行一次就打印一条记录。缓冲区的大小等于一条记录的大小。请用P、V操作来保证文件的正确打印。</p>",
                "questionAnswer": "<p>进程 PA、PB、PC 之间的关系为：PA 与 PB 共用一个单缓冲区，PB 又与 PC 共用一个单缓冲区，其合作方式如下图所示。当缓冲区 1 为空时，进程 PA 可将一条记录读入；若缓冲区 1 中有数据且缓冲区 2 为空，则进程 PB 可将记录从缓冲区 1 复制到缓冲区 2 中；若缓冲区 2 中有数据，则进程 PC 可以打印记录。在其他条件下，相应进程必须等待。事实上，这是一个生产者-消费者问题。</p><p>![image](https://s3.hi168.com/hi168-26998-7111ilq6/exercises/a880e0afe237d80b6a3e3d33b7945b64a3f98c2369ddc05b520afbbe459c4c42-1771687966425.jpg)</p><p>为遵循这一同步规则, 应设置 4 个信号量 empty1、empty2、full1、full2, 信号量 empty1 和 empty2 分别表示缓冲区 1 和缓冲区 2 是否为空, 其初始值为 1; 信号量 full1 和 full2 分别表示缓冲区 1 和缓冲区 2 是否有记录可供处理, 其初始值为 0。相应的进程描述如下:</p><p>```txt</p><p>semaphore empty1=1; //缓冲区1是否为空</p><p>semaphore full1=0; //缓冲区1是否有记录可供处理</p><p>semaphore empty2=1; //缓冲区2是否为空</p><p>semaphore full2=0; //缓冲区2是否有记录可供处理</p><p>cobegin{</p><p>process PA(){</p><p>while (TRUE){</p><p>```</p><p>```txt</p><p>从磁盘读入一条记录；P(empty1)；将记录存入缓冲区1；V(full1);}</p><p>}process PB(){while (TRUE){P(full1);从缓冲区1中取出一条记录；V(empty1);P(empty2);将取出的记录存入缓冲区2；V(full2);}</p><p>}process PC(){while (TRUE){P(full2);从缓冲区2中取出一条记录；V(empty2);将取出的记录打印出来；}</p><p>}coend</p><p>```</p>",
                "questionAnalysis": null,
                "questionScore": 0
            }
        ],
        "fromSchool": "25王道8套",
        "examTime": "2024年",
        "examCode": "408",
        "examFullName": "计算机学科基础综合（七）",
        "exerciseNumber": 45,
        "totalScore": 7,
        "knowledgeTags": [
            "1219616462478778368",
            "1219654910665302016",
            "1219656984048181248"
        ]
    },
    {
        "exerciseType": "解答题",
        "stem": "<p>（8分）某系统采用成组链接法来管理磁盘的空闲空间，当前磁盘的状态如下图所示。</p>",
        "options": [
            {
                "questionOrder": 1,
                "questionStem": "<p>该磁盘中目前还有多少个空闲盘块？</p>",
                "questionAnswer": "<p>由图可见，目前系统共有4组空闲盘块，第1组有2块，第2、3组分别有100块，第4组虽记为100块，但除去结束标记0后实际上只有99块，因此空闲盘块总数为301。</p>",
                "questionAnalysis": null,
                "questionScore": 0
            },
            {
                "questionOrder": 2,
                "questionStem": "<p>在为某个文件F1分配3个盘块后，写出空闲盘块号栈的栈顶盘块号。</p>",
                "questionAnswer": "<p>第 1 组只有 2 个磁盘块, 将第 1 组中的 299 号磁盘块分配给文件 F1 后, 需要将 300 号磁盘块的内容读入栈, 作为新的空闲盘块号栈的内容, 并将 300 号盘块分配给 F1 (其中有用的数据已读入栈), 这样就为该文件分配了 2 个磁盘块, 最后将新的栈顶 301 号对应的盘块分配给 F1, 此时空闲盘块号栈的栈顶盘块号变为 302。</p>",
                "questionAnalysis": null,
                "questionScore": 0
            },
            {
                "questionOrder": 3,
                "questionStem": "<p>在上一问的基础上，删除另一文件F2并回收它所占的5个盘块，盘块号分别是700,711,703,788,701，写出回收后空闲盘块号栈的栈顶指针的值和空闲盘块号。</p><p>![image](https://s3.hi168.com/hi168-26998-7111ilq6/exercises/5c4272d2c87dbad789bae1f97b9f8df92ae9ba374170eb9b4b203793c53fc8db-1771687996008.jpg)</p>",
                "questionAnswer": "<p>回收空闲盘块时, 将回收的盘块号存入空闲盘块号栈的顶部, 并将栈中的空闲盘块数加 1 。回收 700 号盘块后, 栈中的空闲盘块数已达 100 , 表示栈已满, 将现有栈中的 100 个空闲盘块号存入新回收的 711 号盘块, 并将盘块号 711 作为新栈底, 然后继续回收 703, 788, 701 号盘块, 回收结束后, 空闲盘块号栈中依次保存着盘块号 711, 703, 788, 701 , 其中盘块号 701 登记在栈顶, 空闲盘块号栈的栈顶指针 s nfree 的值为 4 。</p>",
                "questionAnalysis": null,
                "questionScore": 0
            }
        ],
        "fromSchool": "25王道8套",
        "examTime": "2024年",
        "examCode": "408",
        "examFullName": "计算机学科基础综合（七）",
        "exerciseNumber": 46,
        "totalScore": 8,
        "knowledgeTags": [
            "1219674307865878528",
            "1219674364837109760"
        ]
    },
    {
        "exerciseType": "解答题",
        "stem": "<p>（9分）本地主机A的一个应用程序使用TCP协议与同一个局域网内的另一台主机B通信。用Sniffer工具捕获主机A以太网发送和接收的所有通信流量，目前已得到8个IP数据报。下表中以十六进制格式逐字节列出了这些IP数据报的全部内容，其中编号2、3、6为主机A收到的IP数据报，其余为主机A发出的IP数据报。假定所有数据报的IP和TCP检验和均是正确的。</p><table><tr><td>编号</td><td colspan=\"19\">IP包的全部内容</td><td></td></tr><tr><td rowspan=\"3\">1</td><td>45</td><td>00</td><td>00</td><td>30</td><td>82</td><td>fc</td><td>40</td><td>00</td><td>80</td><td>06</td><td>f5</td><td>a5</td><td>c0</td><td>a8</td><td>00</td><td>15</td><td>c0</td><td>a8</td><td>00</td><td>c0</td></tr><tr><td>06</td><td>64</td><td>31</td><td>ba</td><td>22</td><td>68</td><td>b9</td><td>90</td><td>00</td><td>00</td><td>00</td><td>00</td><td>70</td><td>02</td><td>ff</td><td>ff</td><td>ec</td><td>e2</td><td>00</td><td>00</td></tr><tr><td>02</td><td>04</td><td>05</td><td>b4</td><td>01</td><td>01</td><td>04</td><td>02</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td rowspan=\"3\">2</td><td>45</td><td>00</td><td>00</td><td>2f</td><td>00</td><td>07</td><td>40</td><td>00</td><td>40</td><td>01</td><td>24</td><td>42</td><td>c0</td><td>a8</td><td>00</td><td>65</td><td>da</td><td>20</td><td>7b</td><td>57</td></tr><tr><td>08</td><td>00</td><td>69</td><td>5a</td><td>36</td><td>6f</td><td>00</td><td>07</td><td>73</td><td>48</td><td>5b</td><td>49</td><td>37</td><td>5c</td><td>04</td><td>00</td><td>08</td><td>09</td><td>0a</td><td>0b</td></tr><tr><td>0c</td><td>0d</td><td>0e</td><td>0f</td><td>10</td><td>11</td><td>12</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td rowspan=\"3\">3</td><td>45</td><td>00</td><td>00</td><td>30</td><td>00</td><td>00</td><td>40</td><td>00</td><td>40</td><td>06</td><td>b8</td><td>a2</td><td>c0</td><td>a8</td><td>00</td><td>c0</td><td>c0</td><td>a8</td><td>00</td><td>15</td></tr><tr><td>31</td><td>ba</td><td>06</td><td>64</td><td>5b</td><td>9f</td><td>f7</td><td>1c</td><td>22</td><td>68</td><td>b9</td><td>91</td><td>70</td><td>12</td><td>20</td><td>00</td><td>83</td><td>45</td><td>00</td><td>00</td></tr><tr><td>02</td><td>04</td><td>05</td><td>b4</td><td>01</td><td>01</td><td>04</td><td>02</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td rowspan=\"2\">4</td><td>45</td><td>00</td><td>00</td><td>28</td><td>82</td><td>fd</td><td>40</td><td>00</td><td>80</td><td>06</td><td>f5</td><td>ac</td><td>c0</td><td>a8</td><td>00</td><td>15</td><td>c0</td><td>a8</td><td>00</td><td>c0</td></tr><tr><td>06</td><td>64</td><td>31</td><td>ba</td><td>22</td><td>68</td><td>b9</td><td>91</td><td>5b</td><td>9f</td><td>f7</td><td>1d</td><td>50</td><td>10</td><td>ff</td><td>ff</td><td>c6</td><td>d9</td><td>00</td><td>00</td></tr><tr><td rowspan=\"3\">5</td><td>45</td><td>00</td><td>00</td><td>38</td><td>82</td><td>fe</td><td>40</td><td>00</td><td>80</td><td>06</td><td>f5</td><td>9b</td><td>c0</td><td>a8</td><td>00</td><td>15</td><td>c0</td><td>a8</td><td>00</td><td>c0</td></tr><tr><td>06</td><td>64</td><td>31</td><td>ba</td><td>22</td><td>68</td><td>b9</td><td>91</td><td>5b</td><td>9f</td><td>f7</td><td>1d</td><td>50</td><td>18</td><td>ff</td><td>ff</td><td>bc</td><td>b7</td><td>00</td><td>00</td></tr><tr><td>f8</td><td>9f</td><td>e3</td><td>e3</td><td>2c</td><td>12</td><td>c2</td><td>89</td><td>24</td><td>34</td><td>6a</td><td>13</td><td>55</td><td>b7</td><td>65</td><td>59</td><td></td><td></td><td></td><td></td></tr><tr><td rowspan=\"2\">6</td><td>45</td><td>00</td><td>00</td><td>28</td><td>3f</td><td>28</td><td>40</td><td>00</td><td>40</td><td>06</td><td>79</td><td>82</td><td>c0</td><td>a8</td><td>00</td><td>c0</td><td>c0</td><td>a8</td><td>00</td><td>15</td></tr><tr><td>31</td><td>ba</td><td>06</td><td>64</td><td>5b</td><td>9f</td><td>f7</td><td>1d</td><td>22</td><td>68</td><td>b9</td><td>a1</td><td>50</td><td>10</td><td>20</td><td>00</td><td>af</td><td>f9</td><td>00</td><td>00</td></tr><tr><td rowspan=\"3\">7</td><td>45</td><td>00</td><td>00</td><td>38</td><td>83</td><td>0b</td><td>40</td><td>00</td><td>80</td><td>06</td><td>f5</td><td>8e</td><td>c0</td><td>a8</td><td>00</td><td>15</td><td>c0</td><td>a8</td><td>00</td><td>c0</td></tr><tr><td>06</td><td>64</td><td>31</td><td>ba</td><td>22</td><td>68</td><td>b9</td><td>a1</td><td>5b</td><td>9f</td><td>f7</td><td>1d</td><td>50</td><td>18</td><td>ff</td><td>ff</td><td>bc</td><td>a7</td><td>00</td><td>00</td></tr><tr><td>f8</td><td>9f</td><td>e3</td><td>e3</td><td>2c</td><td>12</td><td>c2</td><td>89</td><td>24</td><td>34</td><td>6a</td><td>13</td><td>55</td><td>b7</td><td>65</td><td>59</td><td></td><td></td><td></td><td></td></tr><tr><td rowspan=\"4\">8</td><td>45</td><td>00</td><td>00</td><td>48</td><td>83</td><td>3e</td><td>00</td><td>00</td><td>80</td><td>06</td><td>35</td><td>4c</td><td>c0</td><td>a8</td><td>00</td><td>15</td><td>c0</td><td>a8</td><td>00</td><td>c0</td></tr><tr><td>06</td><td>64</td><td>31</td><td>ba</td><td>22</td><td>68</td><td>b9</td><td>a1</td><td>5b</td><td>9f</td><td>f7</td><td>1d</td><td>50</td><td>18</td><td>ff</td><td>ff</td><td>b2</td><td>8d</td><td>00</td><td>00</td></tr><tr><td>f8</td><td>9f</td><td>e3</td><td>e3</td><td>2c</td><td>12</td><td>c2</td><td>89</td><td>24</td><td>34</td><td>6a</td><td>13</td><td>55</td><td>b7</td><td>65</td><td>59</td><td>dd</td><td>47</td><td>2c</td><td>3a</td></tr><tr><td>b1</td><td>0c</td><td>9a</td><td>fl</td><td>75</td><td>1b</td><td>4f</td><td>75</td><td>62</td><td>df</td><td>03</td><td>19</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></table><p>注意，IP分组头结构和TCP段头结构分别如图1和图2所示。协议域为1,6,17,89，它们分别对应ICMP、TCP、UDP、OSPF协议。</p><p>![image](https://s3.hi168.com/hi168-26998-7111ilq6/exercises/06995676a0f4065ebd270be4b2897e953efdc8406b2cd826df6e4d2b9dfb1fae-1771687954993.jpg)</p><p>图1 IP分组头结构</p><p>![image](https://s3.hi168.com/hi168-26998-7111ilq6/exercises/621d86b13f38519e9dc477a03a56c142ceb6ddacecfe8a2477431d5a361ef493-1771687951170.jpg)</p><p>图2 TCP段头结构</p><p>本题中窗口域描述窗口时使用的计量单位为1B。回答下列问题。</p>",
        "options": [
            {
                "questionOrder": 1,
                "questionStem": "<p>在表所示的IP分组中，哪几个分组完成了TCP连接建立过程中的三次握手？根据三次握手报文提供的信息，连接建立后，如果B发数据给A，那么首字节的编号是多少？</p>",
                "questionAnswer": "<p>编号为2,3,6的数据报为主机A收到的IP数据报，其他均为主机A发送的数据报，由主机A发送的数据报中的源IP地址可知主机A的IP地址为c0a80015。对比编号为2,3,6的数据报，可知2号数据报来自一个发送方，3,6号数据报来自同一个发送方，由2号帧的源IP地址和目的IP地址以及其协议字段（ICMP协议）可知，该数据报来自不知名的一方（可能是网络中的某个结点），而3,6号来自主机B，主机B的IP地址为c0a800c0,1号数据报的SYN值为1，3号数据报的SYN值也为1，代表这是前两次握手的数据报，</p><p>根据 IP 数据报标识字段的值可知，4 号数据报是主机 A 发送的第二个 IP 数据报，因此三次握手后应该是编号为 1,3,4 的三个数据报。连接建立后，由主机 A 最后的 4 号确认报文段以及之后发送的 5 号报文段可知，seq 字段为 2268 b991，ack 号为 5b 9ff7 1d，进而可知主机 A 期望收到对方的下一个报文段的数据中的第一个字节的序号为 5b 9ff7 1d，也就是说，如果 B 发送数据给 A，那么首字节的编号应该是 5b 9ff7 1d。</p>",
                "questionAnalysis": null,
                "questionScore": 0
            },
            {
                "questionOrder": 2,
                "questionStem": "<p>根据表中的IP分组，A上的应用程序已经请求TCP发送的应用层数据的总字节是多少？</p>",
                "questionAnswer": "<p>主机 A 从 4 号报文段携带应用层数据, 所以只需将 4, 5, 7, 8 报文中的数据部分加起来, 观察 4, 5, 7, 8 号报文的头部长度字段, 均为 5 , 表示 TCP 头部长度均为 $5 \\times 4 \\mathrm{~B} = 20 \\mathrm{~B}$ , 由图表可知, 从第三行开始的内容均为要传输的数据, 其和为 $0 + 16 + 16 + 32 = 64 \\mathrm{~B}$ 。</p>",
                "questionAnalysis": null,
                "questionScore": 0
            },
            {
                "questionOrder": 3,
                "questionStem": "<p>若在8号IP分组后，B正确收到了A发出的所有IP分组，则B新发给A的TCP报文段中的ack号应当是多少（十六进制）？若在8号IP分组后，A上的应用程序请求TCP发送新的65495B的应用层数据，则按TCP协议，在A未能得到B的任何确认报文之前，TCP可以发送到网络中的应用层数据最多是多少字节？</p>",
                "questionAnswer": "<p>主机B接收到主机A的IP分组后，在8号报文段的序号字段的基础上加上其发送的数据字节数，即 $2268\\mathrm{B}9\\mathrm{A}1\\mathrm{H} + 32\\mathrm{D} = 2268\\mathrm{B}9\\mathrm{C}1\\mathrm{H}$ 。</p><p>B 在 6 号报文段中指出自己的窗口字段为 $</p>",
                "questionAnalysis": null,
                "questionScore": 0
            }
        ],
        "fromSchool": "25王道8套",
        "examTime": "2024年",
        "examCode": "408",
        "examFullName": "计算机学科基础综合（七）",
        "exerciseNumber": 47,
        "totalScore": 9,
        "knowledgeTags": [
            "1220679334461972480",
            "1220695427473743872",
            "1220695475083288576"
        ]
    }
]